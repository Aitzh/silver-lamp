<!DOCTYPE html>
<html lang="ru">
<head>
    <!-- –ê–ù–¢–ò-–§–õ–ï–®: —Å–∏–Ω—Ö—Ä–æ–Ω–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ —Ç–æ–∫–µ–Ω–∞ –¥–æ —Ä–µ–Ω–¥–µ—Ä–∞ -->
    <script>
        (function() {
            try {
                var token = localStorage.getItem('sessionToken');
                var expires = localStorage.getItem('sessionExpiresAt');
                if (!token || !expires || new Date() >= new Date(expires)) {
                    window.location.replace('/login.html');
                } else {
                    document.documentElement.style.visibility = 'hidden';
                }
            } catch(e) {}
        })();
    </script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MineChess | Coffee & AI</title>
    <link rel="icon" type="image/png" href="/logotip.png">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&family=Playfair+Display:wght@600;700;800&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        :root {
            --bg-body: #0F0A07;
            --card-bg: linear-gradient(180deg, rgba(45, 31, 24, 0.85) 0%, rgba(15, 10, 7, 0.95) 100%);
            --glass-border: rgba(212, 165, 116, 0.25);
            --accent: #D4A574;
            --accent-glow: #E8B923;
            --text-main: #F5E6D3;
            --text-muted: #B89F8A;
            --card-shadow: 0 32px 64px rgba(0,0,0,0.6);
            --font-heading: 'Playfair Display', serif;
            --font-body: 'Inter', sans-serif;
            --ease-smooth: cubic-bezier(0.4, 0, 0.2, 1);
            --board-light: #8B6F47;
            --board-dark: #5C4A33;
            --piece-white: #FFFFFF;
            --piece-black: #1A1A1A;
        }

        [data-theme="light"] {
            --bg-body: #F5EDE2;
            --card-bg: linear-gradient(180deg, rgba(255, 248, 240, 0.9) 0%, rgba(255, 248, 240, 0.8) 100%);
            --glass-border: rgba(212, 165, 116, 0.4);
            --accent: #B89F8A;
            --accent-glow: #D4A574;
            --text-main: #3E2F1F;
            --text-muted: #8A7A6D;
            --card-shadow: 0 32px 64px rgba(62, 47, 31, 0.15);
            --board-light: #A68A5C;
            --board-dark: #7A5F3F;
            --piece-white: #FFFFFF;
            --piece-black: #1A1A1A;
        }

        * { box-sizing: border-box; margin: 0; padding: 0; }

        body {
            background-color: var(--bg-body);
            color: var(--text-main);
            font-family: var(--font-body);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
            transition: background 0.5s var(--ease-smooth);
        }

        .game-container {
            width: 100%;
            max-width: 1400px;
            background: var(--card-bg);
            backdrop-filter: blur(24px);
            border: 1px solid var(--glass-border);
            border-top: 1px solid rgba(255,255,255,0.15);
            border-radius: 32px;
            padding: 40px;
            box-shadow: var(--card-shadow);
            position: relative;
            overflow: hidden;
        }

        .game-container::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 100%;
            background: radial-gradient(circle at top center, rgba(212, 165, 116, 0.15) 0%, transparent 60%);
            pointer-events: none;
            z-index: 0;
        }

        .top-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            position: relative;
            z-index: 2;
        }

        .back-btn {
            background: rgba(255,255,255,0.03);
            border: 1px solid var(--glass-border);
            color: var(--text-main);
            padding: 10px 20px;
            border-radius: 50px;
            cursor: pointer;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: all 0.3s ease;
        }

        .back-btn:hover {
            background: rgba(255,255,255,0.08);
            transform: translateX(-3px);
        }

        .theme-toggle {
            background: transparent;
            border: none;
            cursor: pointer;
            color: var(--text-muted);
            transition: color 0.4s var(--ease-smooth);
        }

        .theme-toggle:hover { color: var(--accent); }
        .toggle-track { display: flex; align-items: center; gap: 10px; }
        .theme-toggle i { transition: transform 0.5s var(--ease-smooth), opacity 0.5s var(--ease-smooth); }
        [data-theme="dark"] .icon-sun { opacity: 0.3; transform: scale(0.8); }
        [data-theme="dark"] .icon-moon { color: var(--accent); transform: scale(1.1); }
        [data-theme="light"] .icon-sun { color: var(--accent); transform: scale(1.1); }
        [data-theme="light"] .icon-moon { opacity: 0.3; transform: scale(0.8); }

        .game-header {
            position: relative;
            z-index: 2;
            text-align: center;
            margin-bottom: 40px;
        }

        .game-title {
            font-family: var(--font-heading);
            font-size: 48px;
            background: linear-gradient(90deg, var(--accent), var(--text-main));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 10px;
        }

        .game-subtitle {
            color: var(--text-muted);
            font-size: 16px;
            font-weight: 300;
        }

        .game-layout {
            position: relative;
            z-index: 2;
            display: grid;
            grid-template-columns: 1fr auto;
            gap: 40px;
            align-items: start;
        }

        .board-section {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }

        .turn-indicator {
            font-size: 18px;
            font-weight: 600;
            color: var(--accent);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .chess-board {
            display: grid;
            grid-template-columns: repeat(8, 70px);
            grid-template-rows: repeat(8, 70px);
            gap: 0;
            border: 3px solid rgba(60, 50, 40, 0.8);
            border-radius: 8px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.5);
            background: #3A2F24;
        }

        .cell {
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 40px;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 1px solid rgba(40, 30, 20, 0.3);
        }

        .cell.white { background: var(--board-light); }
        .cell.black { background: var(--board-dark); }

        .cell.piece-white {
            color: var(--piece-white);
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8), 0 0 2px rgba(0,0,0,0.5);
        }

        .cell.piece-black {
            color: var(--piece-black);
            text-shadow: 1px 1px 2px rgba(255,255,255,0.5), 0 0 1px rgba(255,255,255,0.3);
        }

        .cell.closed::after {
            content: '?';
            position: absolute;
            font-size: 24px;
            color: rgba(255,255,255,0.3);
            opacity: 0.5;
        }

        .cell.mine-number::after {
            position: absolute;
            bottom: 4px;
            right: 6px;
            font-size: 18px;
            font-weight: 900;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
        }

        .cell.mine-number.n1::after { content: '1'; color: #4A9EFF; }
        .cell.mine-number.n2::after { content: '2'; color: #4CAF50; }
        .cell.mine-number.n3::after { content: '3'; color: #FFB74D; }
        .cell.mine-number.n4::after { content: '4'; color: #FF7043; }
        .cell.mine-number.n5::after { content: '5'; color: #E91E63; }
        .cell.mine-number.n6::after { content: '6'; color: #9C27B0; }
        .cell.mine-number.n7::after { content: '7'; color: #673AB7; }
        .cell.mine-number.n8::after { content: '8'; color: #F44336; }

        .cell.flagged::before {
            content: 'üö©';
            position: absolute;
            font-size: 28px;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 5;
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.5));
        }

        .cell.show-mine::before {
            content: 'üí£';
            position: absolute;
            font-size: 20px;
            top: 2px;
            left: 2px;
            opacity: 0.8;
            z-index: 10;
        }

        .cell.highlighted {
            background: rgba(76, 175, 80, 0.5) !important;
            box-shadow: inset 0 0 15px rgba(76, 175, 80, 0.8);
        }

        .cell.scout-highlight {
            background: rgba(33, 150, 243, 0.5) !important;
            box-shadow: inset 0 0 15px rgba(33, 150, 243, 0.8);
        }

        .cell.forbidden {
            background: rgba(229, 80, 80, 0.5) !important;
            cursor: not-allowed;
            box-shadow: inset 0 0 15px rgba(229, 80, 80, 0.8);
        }

        .cell.selected {
            border: 3px solid var(--accent) !important;
            box-shadow: 0 0 20px rgba(212, 165, 116, 1);
        }

        .cell.disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .cell.damaged::before {
            content: '‚è≥';
            position: absolute;
            top: -5px;
            right: -5px;
            font-size: 16px;
        }

        .cell.weakened::before {
            content: '‚ö°';
            position: absolute;
            top: -5px;
            right: -5px;
            font-size: 16px;
            color: #FFB74D;
        }

        .cell:hover:not(.forbidden):not(.disabled) {
            transform: scale(1.08);
            filter: brightness(1.2);
        }

        .exploded {
            animation: explosion 0.6s ease-out !important;
        }

        @keyframes explosion {
            0% { transform: scale(1); }
            30% { 
                transform: scale(1.5); 
                background: rgba(255, 69, 0, 0.9) !important;
                box-shadow: 0 0 40px rgba(255, 69, 0, 1);
            }
            100% { transform: scale(1); }
        }

        .side-panel {
            width: 320px;
            display: flex;
            flex-direction: column;
            gap: 24px;
        }

        .panel-card {
            background: rgba(255,255,255,0.03);
            border: 1px solid var(--glass-border);
            border-radius: 20px;
            padding: 24px;
        }

        .panel-title {
            font-size: 13px;
            letter-spacing: 2px;
            color: var(--accent);
            font-weight: 700;
            text-transform: uppercase;
            margin-bottom: 16px;
        }

        .action-btn {
            width: 100%;
            padding: 16px;
            background: linear-gradient(135deg, var(--accent), var(--accent-glow));
            border: none;
            border-radius: 50px;
            color: #0F0A07;
            font-size: 15px;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.4s ease;
            margin-bottom: 12px;
        }

        .action-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 30px rgba(212, 165, 116, 0.4);
        }

        .action-btn.secondary {
            background: rgba(255,255,255,0.05);
            color: var(--text-main);
            border: 1px solid var(--glass-border);
        }

        .action-btn.debug {
            background: rgba(255, 152, 0, 0.2);
            color: var(--accent);
            border: 1px solid rgba(255, 152, 0, 0.3);
            font-size: 13px;
            padding: 12px;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid var(--glass-border);
        }

        .stat-row:last-child { border-bottom: none; }
        .stat-label { font-size: 13px; color: var(--text-muted); }
        .stat-value { font-size: 18px; font-weight: 700; color: var(--accent); }

        .mode-selector {
            display: flex;
            gap: 10px;
        }

        .mode-btn {
            padding: 10px 16px;
            background: rgba(255,255,255,0.03);
            border: 1px solid var(--glass-border);
            color: var(--text-muted);
            border-radius: 50px;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.3s ease;
        }

        .mode-btn.active {
            background: linear-gradient(135deg, var(--accent), var(--accent-glow));
            color: #0F0A07;
            border-color: transparent;
            font-weight: 700;
        }

        /* –ú–æ–¥–∞–ª—å–Ω—ã–µ –æ–∫–Ω–∞ */
        .modal-overlay {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(0,0,0,0.8);
            backdrop-filter: blur(10px);
            z-index: 1000;
            display: flex;
            justify-content: center;
            align-items: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }

        .modal-overlay.active {
            opacity: 1;
            pointer-events: all;
        }

        .modal-card {
            background: var(--card-bg);
            border: 1px solid var(--glass-border);
            border-radius: 24px;
            padding: 40px;
            max-width: 480px;
            width: 90%;
            text-align: center;
            box-shadow: var(--card-shadow);
        }

        .modal-title {
            font-family: var(--font-heading);
            font-size: 36px;
            background: linear-gradient(90deg, var(--accent), var(--text-main));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 16px;
        }

        .modal-text {
            color: var(--text-muted);
            font-size: 16px;
            margin-bottom: 30px;
            line-height: 1.6;
        }

        .guide-modal .modal-card {
            max-width: 560px;
            text-align: left;
        }

        .guide-section {
            margin-bottom: 20px;
        }

        .guide-section-title {
            font-size: 15px;
            font-weight: 700;
            color: var(--accent);
            margin-bottom: 8px;
        }

        .guide-section-text {
            font-size: 14px;
            color: var(--text-muted);
            line-height: 1.6;
        }

        @media (max-width: 1100px) {
            .game-layout {
                grid-template-columns: 1fr;
            }
            .side-panel {
                width: 100%;
                grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
                display: grid;
            }
        }

        @media (max-width: 700px) {
            .chess-board {
                grid-template-columns: repeat(8, 50px);
                grid-template-rows: repeat(8, 50px);
            }
            .cell { font-size: 32px; }
            .game-title { font-size: 36px; }
        }
    </style>
</head>
<body data-theme="dark">
    <div class="game-container">
        <div class="top-bar">
            <button class="back-btn" onclick="window.location.href='/'">
                <i data-lucide="arrow-left" style="width: 16px; height: 16px;"></i>
                <span id="backBtn">–ù–∞–∑–∞–¥</span>
            </button>
            <button onclick="toggleTheme()" class="theme-toggle">
                <div class="toggle-track">
                    <i data-lucide="sun" class="icon-sun" style="width: 20px; height: 20px;"></i>
                    <i data-lucide="moon" class="icon-moon" style="width: 20px; height: 20px;"></i>
                </div>
            </button>
        </div>

        <div class="game-header">
            <h1 class="game-title">‚ôüÔ∏èüí£ MINECHESS</h1>
            <p class="game-subtitle" id="gameSubtitle">–®–∞—Ö–º–∞—Ç—ã √ó –°–∞–ø—ë—Ä | –°—Ç—Ä–∞—Ç–µ–≥–∏—è –ø–æ–¥ –≤—É–∞–ª—å—é —Ç—É–º–∞–Ω–∞ –≤–æ–π–Ω—ã</p>
        </div>

        <div class="game-layout">
            <div class="board-section">
                <div class="turn-indicator" id="turnIndicator">–•–û–î –ë–ï–õ–´–•</div>
                <div class="chess-board" id="chessBoard"></div>
                <div class="mode-selector">
                    <button class="mode-btn active" onclick="setMode('move')" id="modeMove">–•–æ–¥ —Ñ–∏–≥—É—Ä–æ–π</button>
                    <button class="mode-btn" onclick="setMode('scout')" id="modeScout">–†–∞–∑–≤–µ–¥–∫–∞</button>
                    <button class="mode-btn" onclick="setMode('flag')" id="modeFlag">üö© –§–ª–∞–∂–æ–∫</button>
                </div>
            </div>

            <div class="side-panel">
                <div class="panel-card">
                    <div class="panel-title" id="panelControl">üîÑ –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ</div>
                    <button class="action-btn" onclick="restartGame()" id="btnRestart">–ù–æ–≤–∞—è –∏–≥—Ä–∞</button>
                    <button class="action-btn secondary" onclick="toggleGuide()" id="btnRules">–ü—Ä–∞–≤–∏–ª–∞</button>
                    <button class="action-btn debug" onclick="toggleMines()" id="btnDebug">üîç –ü–æ–∫–∞–∑–∞—Ç—å –º–∏–Ω—ã (DEBUG)</button>
                </div>

                <div class="panel-card">
                    <div class="panel-title" id="panelStats">üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞</div>
                    <div class="stat-row">
                        <span class="stat-label" id="statTotal">–í—Å–µ–≥–æ –º–∏–Ω</span>
                        <span class="stat-value" id="totalMines">12</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label" id="statFound">–ù–∞–π–¥–µ–Ω–æ –º–∏–Ω</span>
                        <span class="stat-value" id="foundMines">0</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label" id="statExploded">–í–∑–æ—Ä–≤–∞–Ω–æ</span>
                        <span class="stat-value" id="explodedMines">0</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label" id="statClosed">–ó–∞–∫—Ä—ã—Ç—ã—Ö –∫–ª–µ—Ç–æ–∫</span>
                        <span class="stat-value" id="closedCells">32</span>
                    </div>
                </div>

                <div class="panel-card">
                    <div class="panel-title" id="panelGuide">üìò –ë—ã—Å—Ç—Ä–∞—è —Å–ø—Ä–∞–≤–∫–∞</div>
                    <table style="width: 100%; border-collapse: collapse; font-size: 12px;">
                        <tr>
                            <td style="padding: 8px; text-align: center; font-size: 20px; width: 40px; border-bottom: 1px solid var(--glass-border);">‚ôô</td>
                            <td style="padding: 8px; color: var(--text-muted); border-bottom: 1px solid var(--glass-border);" id="refPawn">–£–Ω–∏—á—Ç–æ–∂–∞–µ—Ç—Å—è</td>
                        </tr>
                        <tr>
                            <td style="padding: 8px; text-align: center; font-size: 20px; border-bottom: 1px solid var(--glass-border);">‚ôò</td>
                            <td style="padding: 8px; color: var(--text-muted); border-bottom: 1px solid var(--glass-border);" id="refKnight">–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç—Å—è –Ω–∞–∑–∞–¥</td>
                        </tr>
                        <tr>
                            <td style="padding: 8px; text-align: center; font-size: 20px; border-bottom: 1px solid var(--glass-border);">‚ôó</td>
                            <td style="padding: 8px; color: var(--text-muted); border-bottom: 1px solid var(--glass-border);" id="refBishop">–£–Ω–∏—á—Ç–æ–∂–∞–µ—Ç—Å—è</td>
                        </tr>
                        <tr>
                            <td style="padding: 8px; text-align: center; font-size: 20px; border-bottom: 1px solid var(--glass-border);">‚ôñ</td>
                            <td style="padding: 8px; color: var(--text-muted); border-bottom: 1px solid var(--glass-border);" id="refRook">–ü—Ä–æ–ø—É—Å–∫–∞–µ—Ç 1 —Ö–æ–¥</td>
                        </tr>
                        <tr>
                            <td style="padding: 8px; text-align: center; font-size: 20px; border-bottom: 1px solid var(--glass-border);">‚ôï</td>
                            <td style="padding: 8px; color: var(--text-muted); border-bottom: 1px solid var(--glass-border);" id="refQueen">–û—Å–ª–∞–±–ª—è–µ—Ç—Å—è –Ω–∞ 2 —Ö–æ–¥–∞</td>
                        </tr>
                        <tr>
                            <td style="padding: 8px; text-align: center; font-size: 20px;">‚ôî</td>
                            <td style="padding: 8px; color: var(--text-muted);" id="refKing">–ù–µ –º–æ–∂–µ—Ç –Ω–∞—Å—Ç—É–ø–∏—Ç—å</td>
                        </tr>
                    </table>
                </div>
            </div>
        </div>
    </div>

    <!-- –ú–æ–¥–∞–ª—å–Ω–æ–µ –æ–∫–Ω–æ –ø–æ–±–µ–¥—ã -->
    <div class="modal-overlay" id="gameOverModal">
        <div class="modal-card">
            <div class="modal-title" id="modalTitle">–ò–≥—Ä–∞ –æ–∫–æ–Ω—á–µ–Ω–∞</div>
            <div class="modal-text" id="modalText"></div>
            <button class="action-btn" onclick="restartGame()" id="modalBtnRestart">–ù–æ–≤–∞—è –∏–≥—Ä–∞</button>
        </div>
    </div>

    <!-- –ú–æ–¥–∞–ª—å–Ω–æ–µ –æ–∫–Ω–æ –ø—Ä–∞–≤–∏–ª -->
    <div class="modal-overlay guide-modal" id="guideModal">
        <div class="modal-card">
            <h2 class="modal-title" id="guideTitle" style="text-align:center; margin-bottom: 24px;">–ü—Ä–∞–≤–∏–ª–∞ MineChess</h2>
            <div class="guide-section">
                <div class="guide-section-title" id="guideGoalTitle">üéØ –¶–µ–ª—å –∏–≥—Ä—ã</div>
                <div class="guide-section-text" id="guideGoalText">–£–Ω–∏—á—Ç–æ–∂–∏—Ç—å –∫–æ—Ä–æ–ª—è –ø—Ä–æ—Ç–∏–≤–Ω–∏–∫–∞, –∏–∑–±–µ–≥–∞—è –º–∏–Ω</div>
            </div>
            <div class="guide-section">
                <div class="guide-section-title" id="guideMinesTitle">üí£ –ú–∏–Ω—ã</div>
                <div class="guide-section-text" id="guideMinesText">–†–∞—Å—Å—Ç–∞–≤–ª—è—é—Ç—Å—è –ø–æ—Å–ª–µ –ø–µ—Ä–≤–æ–≥–æ —Ö–æ–¥–∞. –ù–µ–ª—å–∑—è —Å—Ç–∞–≤–∏—Ç—å –Ω–∞ —Å—Ç–∞—Ä—Ç–æ–≤—ã—Ö —Ä—è–¥–∞—Ö</div>
            </div>
            <div class="guide-section">
                <div class="guide-section-title" id="guideScoutTitle">üîç –†–∞–∑–≤–µ–¥–∫–∞</div>
                <div class="guide-section-text" id="guideScoutText">–í–º–µ—Å—Ç–æ —Ö–æ–¥–∞ –º–æ–∂–Ω–æ —Ä–∞–∑–≤–µ–¥–∞—Ç—å –∫–ª–µ—Ç–∫—É. –ö–∞–∂–¥–∞—è —Ñ–∏–≥—É—Ä–∞ –∏–º–µ–µ—Ç —Å–≤–æ–π —Ä–∞–¥–∏—É—Å —Ä–∞–∑–≤–µ–¥–∫–∏</div>
            </div>
            <div class="guide-section">
                <div class="guide-section-title" id="guideBehaviorTitle">‚öîÔ∏è –ü–æ–≤–µ–¥–µ–Ω–∏–µ –ø—Ä–∏ –ø–æ–¥—Ä—ã–≤–µ</div>
                <div class="guide-section-text" id="guideBehaviorText">–ö–æ—Ä–æ–ª—å –Ω–µ –º–æ–∂–µ—Ç –Ω–∞—Å—Ç—É–ø–∏—Ç—å –Ω–∞ –º–∏–Ω—É. –ö–æ–Ω—å –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç—Å—è. –ü–µ—à–∫–∞ –∏ —Å–ª–æ–Ω –≥–∏–±–Ω—É—Ç. –õ–∞–¥—å—è –ø—Ä–æ–ø—É—Å–∫–∞–µ—Ç —Ö–æ–¥. –§–µ—Ä–∑—å –æ—Å–ª–∞–±–ª—è–µ—Ç—Å—è</div>
            </div>
            <button class="action-btn" onclick="toggleGuide()" id="guideCloseBtn" style="margin-top: 16px;">–ó–∞–∫—Ä—ã—Ç—å</button>
        </div>
    </div>

    <script>
        // ============ –ü–ï–†–ï–í–û–î–´ ============
        const translations = {
            ru: {
                backBtn: '–ù–∞–∑–∞–¥', gameSubtitle: '–®–∞—Ö–º–∞—Ç—ã √ó –°–∞–ø—ë—Ä | –°—Ç—Ä–∞—Ç–µ–≥–∏—è –ø–æ–¥ –≤—É–∞–ª—å—é —Ç—É–º–∞–Ω–∞ –≤–æ–π–Ω—ã',
                turnWhite: '–•–û–î –ë–ï–õ–´–•', turnBlack: '–•–û–î –ß–Å–†–ù–´–•',
                modeMove: '–•–æ–¥ —Ñ–∏–≥—É—Ä–æ–π', modeScout: '–†–∞–∑–≤–µ–¥–∫–∞', modeFlag: 'üö© –§–ª–∞–∂–æ–∫',
                panelControl: 'üîÑ –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ', btnRestart: '–ù–æ–≤–∞—è –∏–≥—Ä–∞', btnRules: '–ü—Ä–∞–≤–∏–ª–∞',
                btnDebug: 'üîç –ü–æ–∫–∞–∑–∞—Ç—å –º–∏–Ω—ã (DEBUG)', panelStats: 'üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞',
                statTotal: '–í—Å–µ–≥–æ –º–∏–Ω', statFound: '–ù–∞–π–¥–µ–Ω–æ –º–∏–Ω', statExploded: '–í–∑–æ—Ä–≤–∞–Ω–æ', statClosed: '–ó–∞–∫—Ä—ã—Ç—ã—Ö –∫–ª–µ—Ç–æ–∫',
                panelGuide: 'üìò –ë—ã—Å—Ç—Ä–∞—è —Å–ø—Ä–∞–≤–∫–∞', refPawn: '–£–Ω–∏—á—Ç–æ–∂–∞–µ—Ç—Å—è', refKnight: '–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç—Å—è –Ω–∞–∑–∞–¥',
                refBishop: '–£–Ω–∏—á—Ç–æ–∂–∞–µ—Ç—Å—è', refRook: '–ü—Ä–æ–ø—É—Å–∫–∞–µ—Ç 1 —Ö–æ–¥', refQueen: '–û—Å–ª–∞–±–ª—è–µ—Ç—Å—è –Ω–∞ 2 —Ö–æ–¥–∞', refKing: '–ù–µ –º–æ–∂–µ—Ç –Ω–∞—Å—Ç—É–ø–∏—Ç—å',
                victoryWhite: '‚ôî –ë–µ–ª—ã–µ –ø–æ–±–µ–¥–∏–ª–∏!', victoryBlack: '‚ôö –ß—ë—Ä–Ω—ã–µ –ø–æ–±–µ–¥–∏–ª–∏!',
                victoryTextWhite: '–ë–µ–ª—ã–µ –ø–æ–±–µ–¥–∏–ª–∏! –ß—ë—Ä–Ω—ã–π –∫–æ—Ä–æ–ª—å —É–Ω–∏—á—Ç–æ–∂–µ–Ω.',
                victoryTextBlack: '–ß—ë—Ä–Ω—ã–µ –ø–æ–±–µ–¥–∏–ª–∏! –ë–µ–ª—ã–π –∫–æ—Ä–æ–ª—å —É–Ω–∏—á—Ç–æ–∂–µ–Ω.',
                modalBtnRestart: '–ù–æ–≤–∞—è –∏–≥—Ä–∞', guideTitle: '–ü—Ä–∞–≤–∏–ª–∞ MineChess',
                guideGoalTitle: 'üéØ –¶–µ–ª—å –∏–≥—Ä—ã', guideGoalText: '–£–Ω–∏—á—Ç–æ–∂–∏—Ç—å –∫–æ—Ä–æ–ª—è –ø—Ä–æ—Ç–∏–≤–Ω–∏–∫–∞, –∏–∑–±–µ–≥–∞—è –º–∏–Ω',
                guideMinesTitle: 'üí£ –ú–∏–Ω—ã', guideMinesText: '–†–∞—Å—Å—Ç–∞–≤–ª—è—é—Ç—Å—è –ø–æ—Å–ª–µ –ø–µ—Ä–≤–æ–≥–æ —Ö–æ–¥–∞. –ù–µ–ª—å–∑—è —Å—Ç–∞–≤–∏—Ç—å –Ω–∞ —Å—Ç–∞—Ä—Ç–æ–≤—ã—Ö —Ä—è–¥–∞—Ö –∏ –∫–ª–µ—Ç–∫–µ –ø–µ—Ä–≤–æ–≥–æ —Ö–æ–¥–∞',
                guideScoutTitle: 'üîç –†–∞–∑–≤–µ–¥–∫–∞', guideScoutText: '–í–º–µ—Å—Ç–æ —Ö–æ–¥–∞ –º–æ–∂–Ω–æ —Ä–∞–∑–≤–µ–¥–∞—Ç—å –∫–ª–µ—Ç–∫—É. –ö–∞–∂–¥–∞—è —Ñ–∏–≥—É—Ä–∞ –∏–º–µ–µ—Ç —Å–≤–æ–π —Ä–∞–¥–∏—É—Å —Ä–∞–∑–≤–µ–¥–∫–∏',
                guideBehaviorTitle: '‚öîÔ∏è –ü–æ–≤–µ–¥–µ–Ω–∏–µ –ø—Ä–∏ –ø–æ–¥—Ä—ã–≤–µ', guideBehaviorText: '–ö–æ—Ä–æ–ª—å –Ω–µ –º–æ–∂–µ—Ç –Ω–∞—Å—Ç—É–ø–∏—Ç—å –Ω–∞ –º–∏–Ω—É. –ö–æ–Ω—å –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç—Å—è. –ü–µ—à–∫–∞ –∏ —Å–ª–æ–Ω –≥–∏–±–Ω—É—Ç. –õ–∞–¥—å—è –ø—Ä–æ–ø—É—Å–∫–∞–µ—Ç —Ö–æ–¥. –§–µ—Ä–∑—å –æ—Å–ª–∞–±–ª—è–µ—Ç—Å—è',
                guideCloseBtn: '–ó–∞–∫—Ä—ã—Ç—å', damagedPiece: '–≠—Ç–∞ —Ñ–∏–≥—É—Ä–∞ –ø–æ–≤—Ä–µ–∂–¥–µ–Ω–∞ –∏ –ø—Ä–æ–ø—É—Å–∫–∞–µ—Ç —Ö–æ–¥!'
            },
            en: {
                backBtn: 'Back', gameSubtitle: 'Chess √ó Minesweeper | Strategy under fog of war',
                turnWhite: 'WHITE TURN', turnBlack: 'BLACK TURN',
                modeMove: 'Move Piece', modeScout: 'Scout', modeFlag: 'üö© Flag',
                panelControl: 'üîÑ Controls', btnRestart: 'New Game', btnRules: 'Rules',
                btnDebug: 'üîç Show Mines (DEBUG)', panelStats: 'üìä Statistics',
                statTotal: 'Total Mines', statFound: 'Mines Found', statExploded: 'Exploded', statClosed: 'Closed Cells',
                panelGuide: 'üìò Quick Reference', refPawn: 'Destroyed', refKnight: 'Returns back',
                refBishop: 'Destroyed', refRook: 'Skips 1 turn', refQueen: 'Weakened 2 turns', refKing: 'Cannot move',
                victoryWhite: '‚ôî White Wins!', victoryBlack: '‚ôö Black Wins!',
                victoryTextWhite: 'White won! Black king destroyed.',
                victoryTextBlack: 'Black won! White king destroyed.',
                modalBtnRestart: 'New Game', guideTitle: 'MineChess Rules',
                guideGoalTitle: 'üéØ Game Goal', guideGoalText: 'Destroy opponent king while avoiding mines',
                guideMinesTitle: 'üí£ Mines', guideMinesText: 'Placed after first move. Cannot be on starting rows or first move cell',
                guideScoutTitle: 'üîç Scouting', guideScoutText: 'Instead of moving, scout a cell. Each piece has scout range',
                guideBehaviorTitle: '‚öîÔ∏è Mine Behavior', guideBehaviorText: 'King cannot step on mines. Knight returns. Pawn and Bishop die. Rook skips turn. Queen weakens',
                guideCloseBtn: 'Close', damagedPiece: 'This piece is damaged and skips turn!'
            },
            kz: {
                backBtn: '–ê—Ä—Ç“õ–∞', gameSubtitle: '–®–∞—Ö–º–∞—Ç √ó –ú–∏–Ω–µ—Ä | –°–æ“ì—ã—Å —Ç—É–º–∞–Ω—ã–Ω–¥–∞“ì—ã —Å—Ç—Ä–∞—Ç–µ–≥–∏—è',
                turnWhite: '–ê“ö –ñ“Æ–†–Ü–°', turnBlack: '“ö–ê–†–ê –ñ“Æ–†–Ü–°',
                modeMove: '–§–∏–≥—É—Ä–∞–Ω—ã –∂—ã–ª–∂—ã—Ç—É', modeScout: '–ë–∞—Ä–ª–∞—É', modeFlag: 'üö© –ñ–∞–ª–∞—É—à–∞',
                panelControl: 'üîÑ –ë–∞—Å“õ–∞—Ä—É', btnRestart: '–ñ–∞“£–∞ –æ–π—ã–Ω', btnRules: '–ï—Ä–µ–∂–µ–ª–µ—Ä',
                btnDebug: 'üîç –ú–∏–Ω–∞–ª–∞—Ä–¥—ã –∫”©—Ä—Å–µ—Ç—É (DEBUG)', panelStats: 'üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞',
                statTotal: '–ë–∞—Ä–ª—ã“õ –º–∏–Ω–∞–ª–∞—Ä', statFound: '–¢–∞–±—ã–ª“ì–∞–Ω', statExploded: '–ñ–∞—Ä—ã–ª“ì–∞–Ω', statClosed: '–ñ–∞–±—ã“õ “±—è—à—ã“õ—Ç–∞—Ä',
                panelGuide: 'üìò –ê–Ω—ã“õ—Ç–∞–º–∞', refPawn: '–ñ–æ–π—ã–ª–∞–¥—ã', refKnight: '–ê—Ä—Ç“õ–∞ “õ–∞–π—Ç–∞–¥—ã',
                refBishop: '–ñ–æ–π—ã–ª–∞–¥—ã', refRook: '1 –∂“Ø—Ä—ñ—Å—Ç—ñ ”©—Ç–∫—ñ–∑–µ–¥—ñ', refQueen: '2 –∂“Ø—Ä—ñ—Å–∫–µ ”ô–ª—Å—ñ—Ä–µ–π–¥—ñ', refKing: '–ñ“Ø—Ä–µ –∞–ª–º–∞–π–¥—ã',
                victoryWhite: '‚ôî –ê“õ –∂–µ“£–¥—ñ!', victoryBlack: '‚ôö “ö–∞—Ä–∞ –∂–µ“£–¥—ñ!',
                victoryTextWhite: '–ê“õ –∂–µ“£–¥—ñ! “ö–∞—Ä–∞ –ø–∞—Ç—à–∞ –∂–æ–π—ã–ª–¥—ã.',
                victoryTextBlack: '“ö–∞—Ä–∞ –∂–µ“£–¥—ñ! –ê“õ –ø–∞—Ç—à–∞ –∂–æ–π—ã–ª–¥—ã.',
                modalBtnRestart: '–ñ–∞“£–∞ –æ–π—ã–Ω', guideTitle: 'MineChess –µ—Ä–µ–∂–µ–ª–µ—Ä—ñ',
                guideGoalTitle: 'üéØ –ú–∞“õ—Å–∞—Ç', guideGoalText: '“ö–∞—Ä—Å—ã–ª–∞—Å –ø–∞—Ç—à–∞—Å—ã–Ω –∂–æ—é, –º–∏–Ω–∞–ª–∞—Ä–¥–∞–Ω –∞—É–ª–∞“õ –±–æ–ª—É',
                guideMinesTitle: 'üí£ –ú–∏–Ω–∞–ª–∞—Ä', guideMinesText: '–ë—ñ—Ä—ñ–Ω—à—ñ –∂“Ø—Ä—ñ—Å—Ç–µ–Ω –∫–µ–π—ñ–Ω –æ—Ä–Ω–∞–ª–∞—Å–∞–¥—ã. –ë–∞—Å—Ç–∞–ø“õ—ã “õ–∞—Ç–æ—Ä–ª–∞—Ä“ì–∞ “õ–æ—é“ì–∞ –±–æ–ª–º–∞–π–¥—ã',
                guideScoutTitle: 'üîç –ë–∞—Ä–ª–∞—É', guideScoutText: '–ñ“Ø—Ä—ñ—Å –æ—Ä–Ω—ã–Ω–∞ “±—è—à—ã“õ—Ç—ã –∑–µ—Ä—Ç—Ç–µ—É–≥–µ –±–æ–ª–∞–¥—ã',
                guideBehaviorTitle: '‚öîÔ∏è ”ò—Ä–µ–∫–µ—Ç', guideBehaviorText: '–ü–∞—Ç—à–∞ –º–∏–Ω–∞“ì–∞ –±–∞—Å–∞ –∞–ª–º–∞–π–¥—ã. –ê—Ç –∞—Ä—Ç“õ–∞ “õ–∞–π—Ç–∞–¥—ã. –ü–µ—à–∫–∞ –º–µ–Ω —Å“Ø“£–≥—ñ ”©–ª–µ–¥—ñ',
                guideCloseBtn: '–ñ–∞–±—É', damagedPiece: '–§–∏–≥—É—Ä–∞ –∑–∞“õ—ã–º–¥–∞–Ω“ì–∞–Ω!'
            }
        };

        let currentLang = localStorage.getItem('currentLang') || 'ru';

        function updateTranslations() {
            const t = translations[currentLang];
            Object.keys(t).forEach(key => {
                const el = document.getElementById(key);
                if (el) el.textContent = t[key];
            });
            updateTurnIndicator();
        }

        function toggleTheme() {
            const body = document.body;
            const currentTheme = body.getAttribute('data-theme');
            const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
            body.setAttribute('data-theme', newTheme);
            localStorage.setItem('theme', newTheme);
            lucide.createIcons();
        }

        const savedTheme = localStorage.getItem('theme') || 'dark';
        document.body.setAttribute('data-theme', savedTheme);

        // ============ STATE ============
        let gameState = {
            currentPlayer: 'white',
            turn: 1,
            mode: 'move',
            board: [],
            pieces: {},
            minesGenerated: false,
            showMines: false,
            selectedPiece: null,
            stats: { totalMines: 12, foundMines: 0, explodedMines: 0 },
            gameOver: false
        };

        const PIECE_SYMBOLS = {
            white: { king: '‚ôî', queen: '‚ôï', rook: '‚ôñ', bishop: '‚ôó', knight: '‚ôò', pawn: '‚ôô' },
            black: { king: '‚ôö', queen: '‚ôõ', rook: '‚ôú', bishop: '‚ôù', knight: '‚ôû', pawn: '‚ôü' }
        };

        // ============ INIT ============
        function initGame() {
            createEmptyBoard();
            placePieces();
            openStartRows();
            gameState.currentPlayer = 'white';
            gameState.turn = 1;
            gameState.mode = 'move';
            gameState.minesGenerated = false;
            gameState.showMines = false;
            gameState.selectedPiece = null;
            gameState.stats = { totalMines: 12, foundMines: 0, explodedMines: 0 };
            gameState.gameOver = false;
            renderBoard();
            updateStats();
            updateTurnIndicator();
        }

        function createEmptyBoard() {
            gameState.board = [];
            for (let row = 0; row < 8; row++) {
                gameState.board[row] = [];
                for (let col = 0; col < 8; col++) {
                    gameState.board[row][col] = {
                        row, col,
                        isOpen: false,
                        hasMine: false,
                        minesAround: 0,
                        pieceId: null,
                        isFlagged: false
                    };
                }
            }
        }

        function placePieces() {
            gameState.pieces = {};
            const backRowPieces = ['rook', 'knight', 'bishop', 'queen', 'king', 'bishop', 'knight', 'rook'];

            for (let col = 0; col < 8; col++) {
                const whiteBackId = `w_${backRowPieces[col]}_${col < 4 ? col : 7 - col}`;
                gameState.pieces[whiteBackId] = {
                    id: whiteBackId, type: backRowPieces[col], color: 'white',
                    row: 0, col, alive: true, hasMoved: false,
                    status: { skipTurns: 0, weakened: false }
                };
                gameState.board[0][col].pieceId = whiteBackId;

                const whitePawnId = `w_pawn_${col}`;
                gameState.pieces[whitePawnId] = {
                    id: whitePawnId, type: 'pawn', color: 'white',
                    row: 1, col, alive: true, hasMoved: false,
                    status: { skipTurns: 0, weakened: false }
                };
                gameState.board[1][col].pieceId = whitePawnId;

                const blackPawnId = `b_pawn_${col}`;
                gameState.pieces[blackPawnId] = {
                    id: blackPawnId, type: 'pawn', color: 'black',
                    row: 6, col, alive: true, hasMoved: false,
                    status: { skipTurns: 0, weakened: false }
                };
                gameState.board[6][col].pieceId = blackPawnId;

                const blackBackId = `b_${backRowPieces[col]}_${col < 4 ? col : 7 - col}`;
                gameState.pieces[blackBackId] = {
                    id: blackBackId, type: backRowPieces[col], color: 'black',
                    row: 7, col, alive: true, hasMoved: false,
                    status: { skipTurns: 0, weakened: false }
                };
                gameState.board[7][col].pieceId = blackBackId;
            }
        }

        function openStartRows() {
            for (let col = 0; col < 8; col++) {
                gameState.board[0][col].isOpen = true;
                gameState.board[1][col].isOpen = true;
                gameState.board[6][col].isOpen = true;
                gameState.board[7][col].isOpen = true;
            }
        }

        function generateMines(excludeRow, excludeCol) {
            const forbidden = new Set();
            for (let col = 0; col < 8; col++) {
                forbidden.add(`0,${col}`); forbidden.add(`1,${col}`);
                forbidden.add(`6,${col}`); forbidden.add(`7,${col}`);
            }
            forbidden.add(`${excludeRow},${excludeCol}`);

            const candidates = [];
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    if (!forbidden.has(`${row},${col}`)) candidates.push({ row, col });
                }
            }

            for (let i = candidates.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [candidates[i], candidates[j]] = [candidates[j], candidates[i]];
            }

            const mineCount = gameState.stats.totalMines;
            for (let i = 0; i < mineCount && i < candidates.length; i++) {
                gameState.board[candidates[i].row][candidates[i].col].hasMine = true;
            }

            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    if (!gameState.board[row][col].hasMine) {
                        let count = 0;
                        for (let dr = -1; dr <= 1; dr++) {
                            for (let dc = -1; dc <= 1; dc++) {
                                if (dr === 0 && dc === 0) continue;
                                const nr = row + dr, nc = col + dc;
                                if (nr >= 0 && nr < 8 && nc >= 0 && nc < 8 && gameState.board[nr][nc].hasMine) count++;
                            }
                        }
                        gameState.board[row][col].minesAround = count;
                    }
                }
            }
            gameState.minesGenerated = true;
        }

        // ============ RENDERING ============
        function renderBoard() {
            const boardElement = document.getElementById('chessBoard');
            boardElement.innerHTML = '';

            for (let row = 7; row >= 0; row--) {
                for (let col = 0; col < 8; col++) {
                    const cell = gameState.board[row][col];
                    const cellDiv = document.createElement('div');
                    cellDiv.className = 'cell ' + ((row + col) % 2 === 0 ? 'white' : 'black');
                    cellDiv.dataset.row = row;
                    cellDiv.dataset.col = col;

                    if (!cell.isOpen) cellDiv.classList.add('closed');

                    if (cell.isFlagged) {
                        cellDiv.classList.add('flagged');
                    } else if (gameState.showMines && cell.hasMine && cell.isOpen) {
                        cellDiv.classList.add('show-mine');
                    } else if (gameState.showMines && cell.hasMine && !cell.isOpen) {
                        cellDiv.classList.add('show-mine');
                    }

                    if (cell.isOpen && cell.minesAround > 0 && !cell.hasMine) {
                        cellDiv.classList.add('mine-number', `n${cell.minesAround}`);
                    }

                    if (cell.pieceId && gameState.pieces[cell.pieceId]?.alive) {
                        const piece = gameState.pieces[cell.pieceId];
                        cellDiv.textContent = PIECE_SYMBOLS[piece.color][piece.type];
                        cellDiv.classList.add(`piece-${piece.color}`);
                        if (piece.status.skipTurns > 0) cellDiv.classList.add('damaged');
                        if (piece.status.weakened) cellDiv.classList.add('weakened');
                    }

                    cellDiv.addEventListener('click', () => handleCellClick(row, col));
                    boardElement.appendChild(cellDiv);
                }
            }
        }

        // ============ CLICK HANDLING ============
        function handleCellClick(row, col) {
            if (gameState.gameOver) return;
            const cell = gameState.board[row][col];

            if (gameState.mode === 'flag') {
                handleFlagMode(cell);
                return;
            }
            if (gameState.mode === 'scout') {
                handleScoutMode(cell);
                return;
            }
            handleMoveMode(cell);
        }

        function handleFlagMode(cell) {
            if (!cell.isOpen) {
                cell.isFlagged = !cell.isFlagged;
                if (cell.isFlagged && cell.hasMine) gameState.stats.foundMines++;
                else if (!cell.isFlagged && cell.hasMine) gameState.stats.foundMines--;
                updateStats();
                renderBoard();
            }
        }

        function handleMoveMode(cell) {
            if (gameState.selectedPiece) {
                const piece = gameState.pieces[gameState.selectedPiece];
                const fromCell = gameState.board[piece.row][piece.col];
                const validMoves = getValidMoves(piece);
                const move = validMoves.find(m => m.row === cell.row && m.col === cell.col);

                if (move) {
                    if (piece.type === 'king' && cell.isOpen && cell.hasMine) {
                        gameState.selectedPiece = null;
                        renderBoard();
                        return;
                    }
                    if (move.type === 'castle-short') { doCastle(piece, 'short'); gameState.selectedPiece = null; renderBoard(); return; }
                    if (move.type === 'castle-long') { doCastle(piece, 'long'); gameState.selectedPiece = null; renderBoard(); return; }
                    makeMove(piece, fromCell, cell);
                } else {
                    gameState.selectedPiece = null;
                    renderBoard();
                }
            } else {
                if (cell.pieceId) {
                    const piece = gameState.pieces[cell.pieceId];
                    if (!canSelectPiece(piece)) {
                        if (piece.status.skipTurns > 0) alert(translations[currentLang].damagedPiece);
                        return;
                    }
                    gameState.selectedPiece = piece.id;
                    highlightMoves(piece);
                }
            }
        }

        function handleScoutMode(cell) {
            if (gameState.selectedPiece) {
                const piece = gameState.pieces[gameState.selectedPiece];
                const scoutCells = getScoutCells(piece);
                if (scoutCells.some(c => c.row === cell.row && c.col === cell.col)) {
                    scoutCell(piece, cell);
                } else {
                    gameState.selectedPiece = null;
                    renderBoard();
                }
            } else {
                if (cell.pieceId) {
                    const piece = gameState.pieces[cell.pieceId];
                    if (!canSelectPiece(piece)) {
                        if (piece.status.skipTurns > 0) alert(translations[currentLang].damagedPiece);
                        return;
                    }
                    gameState.selectedPiece = piece.id;
                    highlightScoutArea(piece);
                }
            }
        }

        function canSelectPiece(piece) {
            return piece.alive && piece.color === gameState.currentPlayer && piece.status.skipTurns === 0;
        }

        // ============ MOVES ============
        function getValidMoves(piece) {
            const moves = [];
            const { row, col, type, color } = piece;
            const enemy = color === 'white' ? 'black' : 'white';

            function addMove(r, c, t = 'normal') {
                if (r < 0 || r > 7 || c < 0 || c > 7) return false;
                const cell = gameState.board[r][c];
                if (cell.pieceId && gameState.pieces[cell.pieceId]?.color === color) return false;
                moves.push({ row: r, col: c, type: t });
                return !cell.pieceId;
            }

            if (type === 'pawn') {
                const dir = color === 'white' ? 1 : -1;
                const startRow = color === 'white' ? 1 : 6;
                const nr = row + dir;
                if (nr >= 0 && nr <= 7 && !gameState.board[nr][col].pieceId) {
                    moves.push({ row: nr, col, type: 'normal' });
                    if (row === startRow && !gameState.board[row + 2 * dir][col].pieceId) {
                        moves.push({ row: row + 2 * dir, col, type: 'normal' });
                    }
                }
                for (const dc of [-1, 1]) {
                    const nc = col + dc;
                    if (nc >= 0 && nc <= 7 && nr >= 0 && nr <= 7) {
                        const target = gameState.board[nr][nc];
                        if (target.pieceId && gameState.pieces[target.pieceId]?.color === enemy) {
                            moves.push({ row: nr, col: nc, type: 'normal' });
                        }
                    }
                }
            } else if (type === 'knight') {
                for (const [dr, dc] of [[-2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]]) {
                    addMove(row + dr, col + dc);
                }
            } else if (type === 'bishop') {
                for (const [dr, dc] of [[-1,-1],[-1,1],[1,-1],[1,1]]) {
                    for (let i = 1; i < 8; i++) { if (!addMove(row + dr*i, col + dc*i)) break; }
                }
            } else if (type === 'rook') {
                for (const [dr, dc] of [[-1,0],[1,0],[0,-1],[0,1]]) {
                    for (let i = 1; i < 8; i++) { if (!addMove(row + dr*i, col + dc*i)) break; }
                }
            } else if (type === 'queen') {
                for (const [dr, dc] of [[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]]) {
                    for (let i = 1; i < 8; i++) { if (!addMove(row + dr*i, col + dc*i)) break; }
                }
            } else if (type === 'king') {
                for (const [dr, dc] of [[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]]) {
                    addMove(row + dr, col + dc);
                }
                if (!piece.hasMoved) {
                    if (canCastle(piece, 'short')) moves.push({ row, col: col + 2, type: 'castle-short' });
                    if (canCastle(piece, 'long')) moves.push({ row, col: col - 2, type: 'castle-long' });
                }
            }
            return moves;
        }

        function canCastle(king, side) {
            if (king.hasMoved) return false;
            const row = king.row;
            const rookCol = side === 'short' ? 7 : 0;
            const rookCell = gameState.board[row][rookCol];
            if (!rookCell.pieceId) return false;
            const rook = gameState.pieces[rookCell.pieceId];
            if (rook.type !== 'rook' || rook.hasMoved) return false;
            const path = side === 'short' ? [5, 6] : [3, 2];
            for (const c of path) {
                if (gameState.board[row][c].pieceId) return false;
                if (gameState.board[row][c].isOpen && gameState.board[row][c].hasMine) return false;
            }
            return true;
        }

        function makeMove(piece, fromCell, toCell) {
            if (!gameState.minesGenerated && gameState.turn === 1 && piece.color === 'white') {
                generateMines(toCell.row, toCell.col);
            }

            if (toCell.pieceId) {
                const captured = gameState.pieces[toCell.pieceId];
                captured.alive = false;
                toCell.pieceId = null;
            }

            fromCell.pieceId = null;
            toCell.pieceId = piece.id;
            piece.row = toCell.row;
            piece.col = toCell.col;
            piece.hasMoved = true;

            openCell(toCell);

            if (toCell.hasMine && !toCell.isFlagged) {
                handleMineHit(piece, toCell);
            }

            checkGameOver();
            if (!gameState.gameOver) endTurn();

            gameState.selectedPiece = null;
            renderBoard();
            updateStats();
        }

        function handleMineHit(piece, cell) {
            cell.hasMine = false;
            gameState.stats.explodedMines++;

            const explodedDiv = document.querySelector(`[data-row="${cell.row}"][data-col="${cell.col}"]`);
            if (explodedDiv) explodedDiv.classList.add('exploded');

            if (piece.type === 'pawn' || piece.type === 'bishop') {
                piece.alive = false;
                cell.pieceId = null;
            } else if (piece.type === 'knight') {
                const prevCell = gameState.board[piece.row][piece.col];
                cell.pieceId = null;
                const backRow = piece.color === 'white' ? piece.row - 1 : piece.row + 1;
                if (backRow >= 0 && backRow <= 7) {
                    piece.row = backRow;
                    gameState.board[backRow][piece.col].pieceId = piece.id;
                } else {
                    piece.alive = false;
                }
            } else if (piece.type === 'rook') {
                piece.status.skipTurns = 1;
            } else if (piece.type === 'queen') {
                piece.status.weakened = true;
                piece.status.skipTurns = 2;
            } else if (piece.type === 'king') {
                piece.alive = false;
                cell.pieceId = null;
            }
        }

        function openCell(cell) {
            cell.isOpen = true;
        }

        function endTurn() {
            gameState.currentPlayer = gameState.currentPlayer === 'white' ? 'black' : 'white';
            gameState.turn++;

            for (const id in gameState.pieces) {
                const p = gameState.pieces[id];
                if (!p.alive) continue;
                if (p.color === gameState.currentPlayer) {
                    if (p.status.skipTurns > 0) p.status.skipTurns--;
                    if (p.status.skipTurns === 0 && p.status.weakened) p.status.weakened = false;
                }
            }

            updateTurnIndicator();
        }

        function checkGameOver() {
            let whiteKingAlive = false, blackKingAlive = false;
            for (const id in gameState.pieces) {
                const p = gameState.pieces[id];
                if (p.type === 'king' && p.alive) {
                    if (p.color === 'white') whiteKingAlive = true;
                    if (p.color === 'black') blackKingAlive = true;
                }
            }
            if (!whiteKingAlive) endGame('black');
            else if (!blackKingAlive) endGame('white');
        }

        function endGame(winner) {
            gameState.gameOver = true;
            const modal = document.getElementById('gameOverModal');
            const t = translations[currentLang];
            document.getElementById('modalTitle').textContent = winner === 'white' ? t.victoryWhite : t.victoryBlack;
            document.getElementById('modalText').textContent = winner === 'white' ? t.victoryTextWhite : t.victoryTextBlack;
            modal.classList.add('active');
        }

        // ============ SCOUT ============
        function getScoutCells(piece) {
            const cells = [];
            const ranges = { pawn: 1, knight: 2, bishop: 2, rook: 3, queen: 4, king: 1 };
            const range = ranges[piece.type] || 1;
            for (let dr = -range; dr <= range; dr++) {
                for (let dc = -range; dc <= range; dc++) {
                    if (dr === 0 && dc === 0) continue;
                    const nr = piece.row + dr, nc = piece.col + dc;
                    if (nr >= 0 && nr < 8 && nc >= 0 && nc < 8 && !gameState.board[nr][nc].isOpen) {
                        cells.push(gameState.board[nr][nc]);
                    }
                }
            }
            return cells;
        }

        function scoutCell(piece, cell) {
            cell.isOpen = true;
            if (cell.hasMine) gameState.stats.foundMines++;
            endTurn();
            gameState.selectedPiece = null;
            renderBoard();
            updateStats();
        }

        // ============ CASTLE ============
        function doCastle(king, side) {
            const row = king.row;
            const fromKingCell = gameState.board[row][king.col];
            if (side === 'short') {
                const rookCell = gameState.board[row][7];
                const rook = gameState.pieces[rookCell.pieceId];
                fromKingCell.pieceId = null;
                gameState.board[row][6].pieceId = king.id;
                king.row = row; king.col = 6; king.hasMoved = true;
                rookCell.pieceId = null;
                gameState.board[row][5].pieceId = rook.id;
                rook.row = row; rook.col = 5; rook.hasMoved = true;
            } else {
                const rookCell = gameState.board[row][0];
                const rook = gameState.pieces[rookCell.pieceId];
                fromKingCell.pieceId = null;
                gameState.board[row][2].pieceId = king.id;
                king.row = row; king.col = 2; king.hasMoved = true;
                rookCell.pieceId = null;
                gameState.board[row][3].pieceId = rook.id;
                rook.row = row; rook.col = 3; rook.hasMoved = true;
            }
            openCell(gameState.board[king.row][king.col]);
            endTurn();
        }

        // ============ HIGHLIGHT ============
        function highlightMoves(piece) {
            renderBoard();
            const cellDiv = document.querySelector(`[data-row="${piece.row}"][data-col="${piece.col}"]`);
            cellDiv.classList.add('selected');
            const validMoves = getValidMoves(piece);
            validMoves.forEach(cell => {
                const moveDiv = document.querySelector(`[data-row="${cell.row}"][data-col="${cell.col}"]`);
                if ((piece.type === 'king' && gameState.board[cell.row][cell.col].isOpen && gameState.board[cell.row][cell.col].hasMine) || gameState.board[cell.row][cell.col].isFlagged) {
                    moveDiv.classList.add('forbidden');
                } else {
                    moveDiv.classList.add('highlighted');
                }
            });
        }

        function highlightScoutArea(piece) {
            renderBoard();
            const cellDiv = document.querySelector(`[data-row="${piece.row}"][data-col="${piece.col}"]`);
            cellDiv.classList.add('selected');
            const scoutCells = getScoutCells(piece);
            scoutCells.forEach(cell => {
                const scoutDiv = document.querySelector(`[data-row="${cell.row}"][data-col="${cell.col}"]`);
                scoutDiv.classList.add('scout-highlight');
            });
        }

        // ============ STATS ============
        function updateStats() {
            document.getElementById('totalMines').textContent = gameState.stats.totalMines;
            document.getElementById('foundMines').textContent = gameState.stats.foundMines;
            document.getElementById('explodedMines').textContent = gameState.stats.explodedMines;
            let closedCount = 0;
            for (let row = 0; row < 8; row++) for (let col = 0; col < 8; col++) if (!gameState.board[row][col].isOpen) closedCount++;
            document.getElementById('closedCells').textContent = closedCount;
        }

        function updateTurnIndicator() {
            const t = translations[currentLang];
            document.getElementById('turnIndicator').textContent = gameState.currentPlayer === 'white' ? t.turnWhite : t.turnBlack;
        }

        function setMode(mode) {
            gameState.mode = mode;
            gameState.selectedPiece = null;
            document.querySelectorAll('.mode-btn').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
            renderBoard();
        }

        function restartGame() {
            document.getElementById('gameOverModal').classList.remove('active');
            document.getElementById('guideModal').classList.remove('active');
            initGame();
        }

        function toggleGuide() {
            document.getElementById('guideModal').classList.toggle('active');
        }

        function toggleMines() {
            gameState.showMines = !gameState.showMines;
            renderBoard();
        }

        // ============ –ó–ê–ü–£–°–ö ============
        lucide.createIcons();
        updateTranslations();
        initGame();

        // –ê–ù–¢–ò-–§–õ–ï–®: –ø—Ä–æ–≤–µ—Ä–∫–∞ —Å–µ—Å—Å–∏–∏ + –ø–æ–∫–∞–∑ —Å—Ç—Ä–∞–Ω–∏—Ü—ã
        (async function() {
            const token = localStorage.getItem('sessionToken');
            try {
                const response = await fetch('/access/status', {
                    headers: { 'X-Session-Token': token }
                });
                const data = await response.json();
                if (!data.authenticated) {
                    localStorage.removeItem('sessionToken');
                    localStorage.removeItem('sessionExpiresAt');
                    window.location.replace('/login.html');
                    return;
                }
            } catch(e) {
                // –ü—Ä–∏ –æ—à–∏–±–∫–µ —Å–µ—Ç–∏ –Ω–µ —Ä–µ–¥–∏—Ä–µ–∫—Ç–∏–º
            }
            document.documentElement.style.visibility = '';
        })();

        // –û—Ç–∫–ª—é—á–∞–µ–º bfcache ‚Äî –ø—Ä–∏ –Ω–∞–∂–∞—Ç–∏–∏ "–ù–∞–∑–∞–¥" –ø–µ—Ä–µ–ø—Ä–æ–≤–µ—Ä—è–µ–º
        window.addEventListener('pageshow', function(event) {
            if (event.persisted) {
                const token = localStorage.getItem('sessionToken');
                const expires = localStorage.getItem('sessionExpiresAt');
                if (!token || !expires || new Date() >= new Date(expires)) {
                    window.location.replace('/login.html');
                }
            }
        });
    </script>
</body>
</html>